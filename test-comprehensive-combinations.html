<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comprehensive Cost Calculation Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        .section {
            margin-bottom: 30px;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 20px;
            background-color: #f9f9f9;
        }
        .success {
            color: #27ae60;
            font-weight: bold;
        }
        .error {
            color: #e74c3c;
            font-weight: bold;
        }
        .warning {
            color: #f39c12;
            font-weight: bold;
        }
        .info {
            color: #3498db;
        }
        pre {
            background-color: #f1f1f1;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        button:hover {
            background-color: #2980b9;
        }
        button.primary {
            background-color: #2ecc71;
        }
        button.primary:hover {
            background-color: #27ae60;
        }
        button.secondary {
            background-color: #95a5a6;
        }
        button.secondary:hover {
            background-color: #7f8c8d;
        }
        button.danger {
            background-color: #e74c3c;
        }
        button.danger:hover {
            background-color: #c0392b;
        }
        .result-container {
            margin-top: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        .filters {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        .filter-group {
            flex: 1;
            min-width: 200px;
        }
        .filter-group h3 {
            margin-top: 0;
            margin-bottom: 10px;
        }
        select, input {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        .test-case {
            margin-bottom: 15px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fff;
        }
        .test-case.passed {
            border-left: 5px solid #27ae60;
        }
        .test-case.failed {
            border-left: 5px solid #e74c3c;
        }
        .test-case-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        .test-case-details {
            margin-top: 15px;
            display: none;
        }
        .test-case.expanded .test-case-details {
            display: block;
        }
        .progress-bar-container {
            width: 100%;
            height: 30px;
            background-color: #f1f1f1;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .progress-bar {
            height: 100%;
            border-radius: 5px;
            background-color: #4CAF50;
            text-align: center;
            line-height: 30px;
            color: white;
        }
        .summary-boxes {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        .summary-box {
            flex: 1;
            padding: 20px;
            border-radius: 5px;
            text-align: center;
            margin: 0 10px;
        }
        .summary-box.passed {
            background-color: #d4edda;
            color: #155724;
        }
        .summary-box.failed {
            background-color: #f8d7da;
            color: #721c24;
        }
        .summary-box.total {
            background-color: #e2e3e5;
            color: #383d41;
        }
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #09f;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <h1>Comprehensive Cost Calculation Test</h1>
    <p>This page tests all combinations of care service types and frequencies to ensure there are no bugs or errors in the calculations.</p>
    
    <div class="section">
        <h2>Test Controls</h2>
        <button id="runRepresentativeTests" class="primary">Run Representative Tests</button>
        <button id="runAllTests" class="secondary">Run All Combinations (Warning: May be slow)</button>
        <button id="runSpecificTest" class="secondary">Run Specific Test</button>
        <button id="clearResults" class="danger">Clear Results</button>
    </div>
    
    <div id="specificTestConfig" class="section" style="display: none;">
        <h2>Configure Specific Test</h2>
        <div class="filters">
            <div class="filter-group">
                <h3>Care Category</h3>
                <select id="categoryFilter">
                    <option value="">Select Category</option>
                    <!-- Options will be populated by JavaScript -->
                </select>
            </div>
            <div class="filter-group">
                <h3>Frequency</h3>
                <select id="frequencyFilter">
                    <option value="">Select Frequency</option>
                    <!-- Options will be populated by JavaScript -->
                </select>
            </div>
            <div class="filter-group">
                <h3>Duration</h3>
                <select id="durationFilter">
                    <option value="">Select Duration</option>
                    <!-- Options will be populated by JavaScript -->
                </select>
            </div>
            <div class="filter-group">
                <h3>Geographic Adjustment</h3>
                <select id="geoFilter">
                    <option value="">Select Geographic Adjustment</option>
                    <!-- Options will be populated by JavaScript -->
                </select>
            </div>
            <div class="filter-group">
                <h3>CPT Code</h3>
                <select id="cptFilter">
                    <option value="">Select CPT Code</option>
                    <!-- Options will be populated by JavaScript -->
                </select>
            </div>
            <div class="filter-group">
                <h3>Age Increments</h3>
                <select id="ageIncrementFilter">
                    <option value="">Select Age Increments</option>
                    <!-- Options will be populated by JavaScript -->
                </select>
            </div>
        </div>
        <button id="runConfiguredTest" class="primary">Run Configured Test</button>
    </div>
    
    <div id="loading" class="loading">
        <div class="spinner"></div>
        <p>Running tests... <span id="progressText">0/0</span></p>
    </div>
    
    <div id="summarySection" class="section" style="display: none;">
        <h2>Test Summary</h2>
        <div class="summary-boxes">
            <div class="summary-box passed">
                <h2 id="passedCount">0</h2>
                <p>Passed Tests</p>
            </div>
            <div class="summary-box failed">
                <h2 id="failedCount">0</h2>
                <p>Failed Tests</p>
            </div>
            <div class="summary-box total">
                <h2 id="totalCount">0</h2>
                <p>Total Tests</p>
            </div>
        </div>
        <div class="progress-bar-container">
            <div id="progressBar" class="progress-bar" style="width: 0%">0%</div>
        </div>
    </div>
    
    <div id="resultsSection" class="section" style="display: none;">
        <h2>Test Results</h2>
        <div class="filters">
            <div class="filter-group">
                <h3>Filter Results</h3>
                <select id="resultFilter">
                    <option value="all">All Results</option>
                    <option value="passed">Passed Only</option>
                    <option value="failed">Failed Only</option>
                </select>
            </div>
            <div class="filter-group">
                <h3>Search</h3>
                <input type="text" id="searchFilter" placeholder="Search test cases...">
            </div>
        </div>
        <div id="resultsContainer" class="result-container"></div>
    </div>
    
    <script>
        // Care categories
        const CARE_CATEGORIES = [
            'Medical',
            'Therapy',
            'Nursing',
            'Personal Care',
            'Home Health',
            'Equipment',
            'Supplies',
            'Medications',
            'Transportation',
            'Housing',
            'Nutrition',
            'Recreation',
            'Education'
        ];

        // Frequency patterns
        const FREQUENCY_PATTERNS = [
            'daily',
            'weekly',
            'monthly',
            'quarterly',
            'annually',
            'one-time',
            'once',
            '2x daily',
            '3x daily',
            '2x weekly',
            '3x weekly',
            '2x monthly',
            '3x monthly',
            '2x annually',
            '3x annually',
            'every 2 days',
            'every 3 days',
            'every 2 weeks',
            'every 3 weeks',
            'every 2 months',
            'every 3 months'
        ];

        // Duration scenarios
        const DURATION_SCENARIOS = [
            { startAge: 30, endAge: 80, lifeExpectancy: 85, description: 'Start 30, End 80, Life Expectancy 85' },
            { startAge: 40, endAge: null, lifeExpectancy: 85, description: 'Start 40, No End, Life Expectancy 85' },
            { startAge: 50, endAge: 60, lifeExpectancy: 85, description: 'Start 50, End 60, Life Expectancy 85' }
        ];

        // Geographic adjustment scenarios
        const GEO_ADJUSTMENT_SCENARIOS = [
            { zipCode: '10001', description: 'New York (high cost)' },
            { zipCode: '60601', description: 'Chicago (medium cost)' },
            { zipCode: '00000', description: 'Invalid ZIP (no adjustment)' }
        ];

        // CPT code scenarios
        const CPT_CODE_SCENARIOS = [
            { cptCode: '99213', description: 'Standard office visit' },
            { cptCode: '97110', description: 'Physical therapy' },
            { cptCode: 'no-mfu', description: 'No MFU data' },
            { cptCode: 'no-pfr', description: 'No PFR data' },
            { cptCode: 'invalid', description: 'Invalid CPT code' }
        ];

        // Age increment scenarios
        const AGE_INCREMENT_SCENARIOS = [
            { value: null, description: 'No age increments' },
            { 
                value: [
                    { startAge: 30, endAge: 50, adjustmentFactor: 1.0 },
                    { startAge: 51, endAge: 70, adjustmentFactor: 1.2 },
                    { startAge: 71, endAge: 85, adjustmentFactor: 1.5 }
                ],
                description: 'Standard age increments'
            }
        ];

        // Helper functions
        function formatCurrency(value) {
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD'
            }).format(value);
        }
        
        function appendMessage(element, message, type = 'info') {
            const p = document.createElement('p');
            p.className = type;
            p.innerHTML = message;
            element.appendChild(p);
        }
        
        function appendJson(element, data) {
            const pre = document.createElement('pre');
            pre.textContent = JSON.stringify(data, null, 2);
            element.appendChild(pre);
        }
        
        function appendTable(element, data, headers) {
            const table = document.createElement('table');
            
            // Create header row
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            
            headers.forEach(header => {
                const th = document.createElement('th');
                th.textContent = header;
                headerRow.appendChild(th);
            });
            
            thead.appendChild(headerRow);
            table.appendChild(thead);
            
            // Create body rows
            const tbody = document.createElement('tbody');
            
            if (Array.isArray(data)) {
                // Array of objects
                data.forEach(item => {
                    const row = document.createElement('tr');
                    
                    Object.values(item).forEach(value => {
                        const td = document.createElement('td');
                        td.textContent = value;
                        row.appendChild(td);
                    });
                    
                    tbody.appendChild(row);
                });
            } else {
                // Single object
                const row = document.createElement('tr');
                
                Object.values(data).forEach(value => {
                    const td = document.createElement('td');
                    td.textContent = value;
                    row.appendChild(td);
                });
                
                tbody.appendChild(row);
            }
            
            table.appendChild(tbody);
            element.appendChild(table);
        }
        
        // Mock CPT code data for testing
        function getMockCptData(cptCode) {
            if (cptCode === 'invalid') {
                return null;
            }
            
            const baseCptData = {
                code: cptCode || '99213',
                code_description: 'Office/outpatient visit',
                mfr_50th: 100.00,
                mfr_75th: 150.00,
                pfr_50th: 120.00,
                pfr_75th: 180.00
            };
            
            if (cptCode === 'no-mfu') {
                delete baseCptData.mfr_50th;
                delete baseCptData.mfr_75th;
            }
            
            if (cptCode === 'no-pfr') {
                delete baseCptData.pfr_50th;
                delete baseCptData.pfr_75th;
            }
            
            return baseCptData;
        }
        
        // Mock geographic factors for testing
        function getMockGeoFactors(zipCode) {
            if (zipCode === '00000') {
                return {
                    mfr_factor: 1.0,
                    pfr_factor: 1.0
                };
            }
            
            if (zipCode === '10001') {
                return {
                    mfr_factor: 1.2,
                    pfr_factor: 1.3
                };
            }
            
            return {
                mfr_factor: 1.1,
                pfr_factor: 1.15
            };
        }
        
        // Parse frequency
        function parseFrequency(frequencyStr) {
            if (!frequencyStr) {
                return { lowFrequency: 0, highFrequency: 0, isOneTime: false, valid: false, error: 'No frequency provided' };
            }
            
            const frequencyLower = frequencyStr.toLowerCase().trim();
            
            // Check for one-time frequencies
            if (frequencyLower === 'one-time' || frequencyLower === 'once' || frequencyLower === 'one time') {
                return { lowFrequency: 0, highFrequency: 0, isOneTime: true, valid: true, original: frequencyStr };
            }
            
            // Handle common frequencies
            if (frequencyLower === 'daily') {
                return { lowFrequency: 365, highFrequency: 365, isOneTime: false, valid: true, original: frequencyStr };
            }
            
            if (frequencyLower === 'weekly') {
                return { lowFrequency: 52, highFrequency: 52, isOneTime: false, valid: true, original: frequencyStr };
            }
            
            if (frequencyLower === 'monthly') {
                return { lowFrequency: 12, highFrequency: 12, isOneTime: false, valid: true, original: frequencyStr };
            }
            
            if (frequencyLower === 'quarterly') {
                return { lowFrequency: 4, highFrequency: 4, isOneTime: false, valid: true, original: frequencyStr };
            }
            
            if (frequencyLower === 'annually' || frequencyLower === 'yearly') {
                return { lowFrequency: 1, highFrequency: 1, isOneTime: false, valid: true, original: frequencyStr };
            }
            
            // Handle multipliers (e.g., 2x daily, 3x weekly)
            const multiplierMatch = frequencyLower.match(/^(\d+)x\s+(daily|weekly|monthly|quarterly|annually|yearly)$/);
            if (multiplierMatch) {
                const multiplier = parseInt(multiplierMatch[1], 10);
                const period = multiplierMatch[2];
                
                let baseFrequency = 0;
                if (period === 'daily') baseFrequency = 365;
                else if (period === 'weekly') baseFrequency = 52;
                else if (period === 'monthly') baseFrequency = 12;
                else if (period === 'quarterly') baseFrequency = 4;
                else if (period === 'annually' || period === 'yearly') baseFrequency = 1;
                
                const frequency = baseFrequency * multiplier;
                return { lowFrequency: frequency, highFrequency: frequency, isOneTime: false, valid: true, original: frequencyStr };
            }
            
            // Handle "every X" patterns (e.g., every 2 days, every 3 weeks)
            const everyMatch = frequencyLower.match(/^every\s+(\d+)\s+(days?|weeks?|months?|years?)$/);
            if (everyMatch) {
                const interval = parseInt(everyMatch[1], 10);
                const period = everyMatch[2].replace(/s$/, ''); // Remove trailing 's' if present
                
                let baseFrequency = 0;
                if (period === 'day') baseFrequency = 365;
                else if (period === 'week') baseFrequency = 52;
                else if (period === 'month') baseFrequency = 12;
                else if (period === 'year') baseFrequency = 1;
                
                const frequency = baseFrequency / interval;
                return { lowFrequency: frequency, highFrequency: frequency, isOneTime: false, valid: true, original: frequencyStr };
            }
            
            // Handle "X per Y" patterns (e.g., 2 per week, 3 per month)
            const perMatch = frequencyLower.match(/^(\d+)\s+(?:times\s+)?per\s+(day|week|month|year)$/);
            if (perMatch) {
                const times = parseInt(perMatch[1], 10);
                const period = perMatch[2];
                
                let baseFrequency = 0;
                if (period === 'day') baseFrequency = 365;
                else if (period === 'week') baseFrequency = 52;
                else if (period === 'month') baseFrequency = 12;
                else if (period === 'year') baseFrequency = 1;
                
                const frequency = baseFrequency * (times / 1); // times per 1 period
                return { lowFrequency: frequency, highFrequency: frequency, isOneTime: false, valid: true, original: frequencyStr };
            }
            
            // If we couldn't parse the frequency, return an error
            return { lowFrequency: 0, highFrequency: 0, isOneTime: false, valid: false, error: `Could not parse frequency: ${frequencyStr}`, original: frequencyStr };
        }
        
        // Calculate duration
        function calculateDuration(params) {
            const { startAge, endAge, lifeExpectancy } = params;
            
            if (startAge === undefined || startAge === null) {
                return { lowDuration: 0, highDuration: 0, valid: false, error: 'No start age provided', source: 'default' };
            }
            
            if (lifeExpectancy === undefined || lifeExpectancy === null) {
                return { lowDuration: 0, highDuration: 0, valid: false, error: 'No life expectancy provided', source: 'default' };
            }
            
            // If end age is provided, use it to calculate duration
            if (endAge !== undefined && endAge !== null) {
                if (endAge < startAge) {
                    return { lowDuration: 0, highDuration: 0, valid: false, error: 'End age cannot be less than start age', source: 'age-range' };
                }
                
                return { lowDuration: endAge - startAge, highDuration: endAge - startAge, valid: true, source: 'age-range' };
            }
            
            // If no end age, use life expectancy
            if (startAge > lifeExpectancy) {
                return { lowDuration: 0, highDuration: 0, valid: false, error: 'Start age cannot be greater than life expectancy', source: 'default' };
            }
            
            return { lowDuration: lifeExpectancy - startAge, highDuration: lifeExpectancy - startAge, valid: true, source: 'default' };
        }
        
        // Calculate costs
        function calculateCosts(params) {
            try {
                // Parse frequency
                const parsedFrequency = parseFrequency(params.frequency);
                if (!parsedFrequency.valid) {
                    throw new Error(`Invalid frequency: ${parsedFrequency.error}`);
                }
                
                // Calculate duration
                const parsedDuration = calculateDuration(params);
                if (!parsedDuration.valid) {
                    throw new Error(`Invalid duration: ${parsedDuration.error}`);
                }
                
                // Get CPT code data if provided
                let cptData = null;
                if (params.cptCode) {
                    cptData = getMockCptData(params.cptCode);
                }
                
                // Get geographic factors if provided
                let geoFactors = { mfr_factor: 1.0, pfr_factor: 1.0 };
                if (params.zipCode) {
                    geoFactors = getMockGeoFactors(params.zipCode);
                }
                
                // Calculate base rate
                let baseRate = params.baseRate || 0;
                let low = baseRate;
                let high = baseRate;
                let average = baseRate;
                
                // If CPT code data is available, use it to calculate base rate
                if (cptData) {
                    const hasMfrData = cptData.mfr_50th !== undefined && cptData.mfr_75th !== undefined;
                    const hasPfrData = cptData.pfr_50th !== undefined && cptData.pfr_75th !== undefined;
                    
                    if (!hasMfrData && !hasPfrData) {
                        throw new Error('No MFR or PFR data available for CPT code');
                    }
                    
                    // Apply geographic factors to percentiles
                    const adjustedMfr50th = hasMfrData ? cptData.mfr_50th * geoFactors.mfr_factor : 0;
                    const adjustedMfr75th = hasMfrData ? cptData.mfr_75th * geoFactors.mfr_factor : 0;
                    const adjustedPfr50th = hasPfrData ? cptData.pfr_50th * geoFactors.pfr_factor : 0;
                    const adjustedPfr75th = hasPfrData ? cptData.pfr_75th * geoFactors.pfr_factor : 0;
                    
                    // Calculate combined base rates
                    if (hasMfrData && hasPfrData) {
                        low = (adjustedMfr50th + adjustedPfr50th) / 2;
                        high = (adjustedMfr75th + adjustedPfr75th) / 2;
                    } else if (hasMfrData) {
                        low = adjustedMfr50th;
                        high = adjustedMfr75th;
                    } else {
                        low = adjustedPfr50th;
                        high = adjustedPfr75th;
                    }
                    
                    average = (low + high) / 2;
                    
                    // Store MFR and PFR costs for reference
                    const mfrCosts = hasMfrData ? {
                        low: adjustedMfr50th,
                        high: adjustedMfr75th,
                        average: (adjustedMfr50th + adjustedMfr75th) / 2
                    } : undefined;
                    
                    const pfrCosts = hasPfrData ? {
                        low: adjustedPfr50th,
                        high: adjustedPfr75th,
                        average: (adjustedPfr50th + adjustedPfr75th) / 2
                    } : undefined;
                }
                
                // For one-time costs, annual is 0 and lifetime is the base rate
                if (parsedFrequency.isOneTime) {
                    return {
                        annual: 0,
                        lifetime: average,
                        low: low,
                        high: high,
                        average: average,
                        isOneTime: true
                    };
                }
                
                // For recurring costs, calculate annual and lifetime costs
                const frequency = parsedFrequency.lowFrequency;
                const duration = parsedDuration.lowDuration;
                
                const annual = average * frequency;
                const lifetime = annual * duration;
                
                // Apply age increments if provided
                if (params.ageIncrements && Array.isArray(params.ageIncrements)) {
                    // This is a simplified version of age increment calculations
                    // In a real implementation, this would be more complex
                    let totalCost = 0;
                    let currentAge = params.startAge;
                    const endAge = params.endAge || params.lifeExpectancy;
                    
                    for (const increment of params.ageIncrements) {
                        if (currentAge >= endAge) break;
                        
                        const incrementStartAge = Math.max(currentAge, increment.startAge);
                        const incrementEndAge = Math.min(endAge, increment.endAge);
                        
                        if (incrementStartAge < incrementEndAge) {
                            const incrementDuration = incrementEndAge - incrementStartAge;
                            const incrementAnnual = annual * increment.adjustmentFactor;
                            const incrementCost = incrementAnnual * incrementDuration;
                            totalCost += incrementCost;
                        }
                        
                        currentAge = Math.max(currentAge, increment.endAge);
                    }
                    
                    return {
                        annual: annual,
                        lifetime: totalCost,
                        low: low * frequency * duration,
                        high: high * frequency * duration,
                        average: average * frequency * duration,
                        isOneTime: false
                    };
                }
                
                return {
                    annual: annual,
                    lifetime: lifetime,
                    low: low * frequency * duration,
                    high: high * frequency * duration,
                    average: average * frequency * duration,
                    isOneTime: false
                };
            } catch (error) {
                throw new Error(`Error calculating costs: ${error.message}`);
            }
        }
        
        // Generate all possible test combinations
        function generateTestCombinations() {
            const combinations = [];
            
            // Generate combinations
            for (const category of CARE_CATEGORIES) {
                for (const frequency of FREQUENCY_PATTERNS) {
                    for (const duration of DURATION_SCENARIOS) {
                        for (const geoAdjustment of GEO_ADJUSTMENT_SCENARIOS) {
                            for (const cptCode of CPT_CODE_SCENARIOS) {
                                for (const ageIncrements of AGE_INCREMENT_SCENARIOS) {
                                    // Base test case
                                    const baseCase = {
                                        name: `${category} - ${frequency} - ${cptCode.description}`,
                                        params: {
                                            category,
                                            frequency,
                                            baseRate: 100,
                                            startAge: duration.startAge,
                                            endAge: duration.endAge,
                                            lifeExpectancy: duration.lifeExpectancy,
                                            zipCode: geoAdjustment.zipCode,
                                            cptCode: cptCode.cptCode,
                                            ageIncrements: ageIncrements.value
                                        }
                                    };
                                    
                                    combinations.push(baseCase);
                                    
                                    // Edge case: zero base rate
                                    combinations.push({
                                        name: `${category} - ${frequency} - Zero base rate`,
                                        params: {
                                            ...baseCase.params,
                                            baseRate: 0
                                        }
                                    });
                                    
                                    // Edge case: very high base rate
                                    combinations.push({
                                        name: `${category} - ${frequency} - High base rate`,
                                        params: {
                                            ...baseCase.params,
                                            baseRate: 10000
                                        }
                                    });
                                    
                                    // Edge case: start age equals end age
                                    if (duration.endAge !== null) {
                                        combinations.push({
                                            name: `${category} - ${frequency} - Start age equals end age`,
                                            params: {
                                                ...baseCase.params,
                                                startAge: duration.startAge,
                                                endAge: duration.startAge
                                            }
                                        });
                                    }
                                    
                                    // Edge case: start age greater than life expectancy
                                    combinations.push({
                                        name: `${category} - ${frequency} - Start age > life expectancy`,
                                        params: {
                                            ...baseCase.params,
                                            startAge: duration.lifeExpectancy + 5
                                        }
                                    });
                                }
                            }
                        }
                    }
                }
            }
            
            return combinations;
        }
        
        // Generate a representative subset of test combinations
        function generateRepresentativeTestCombinations() {
            const combinations = [];
            
            // Select representative categories
            const repCategories = ['Medical', 'Therapy', 'Equipment', 'Medications', 'Transportation'];
            
            // Select representative frequencies
            const repFrequencies = ['daily', 'weekly', 'monthly', 'annually', 'one-time', '2x daily', '3x weekly', 'every 2 months'];
            
            // Select representative durations
            const repDurations = [
                { startAge: 30, endAge: 80, lifeExpectancy: 85, description: 'Start 30, End 80, Life Expectancy 85' },
                { startAge: 40, endAge: null, lifeExpectancy: 85, description: 'Start 40, No End, Life Expectancy 85' }
            ];
            
            // Select representative geographic adjustments
            const repGeoAdjustments = [
                { zipCode: '10001', description: 'New York (high cost)' },
                { zipCode: '00000', description: 'Invalid ZIP (no adjustment)' }
            ];
            
            // Select representative CPT codes
            const repCptCodes = [
                { cptCode: '99213', description: 'Standard office visit' },
                { cptCode: 'invalid', description: 'Invalid CPT code' }
            ];
            
            // Select representative age increments
            const repAgeIncrements = AGE_INCREMENT_SCENARIOS;
            
            // Generate combinations
            for (const category of repCategories) {
                for (const frequency of repFrequencies) {
                    for (const duration of repDurations) {
                        for (const geoAdjustment of repGeoAdjustments) {
                            for (const cptCode of repCptCodes) {
                                for (const ageIncrements of repAgeIncrements) {
                                    // Base test case
                                    const baseCase = {
                                        name: `${category} - ${frequency} - ${cptCode.description}`,
                                        params: {
                                            category,
                                            frequency,
                                            baseRate: 100,
                                            startAge: duration.startAge,
                                            endAge: duration.endAge,
                                            lifeExpectancy: duration.lifeExpectancy,
                                            zipCode: geoAdjustment.zipCode,
                                            cptCode: cptCode.cptCode,
                                            ageIncrements: ageIncrements.value
                                        }
                                    };
                                    
                                    combinations.push(baseCase);
                                    
                                    // Add a few edge cases
                                    if (category === 'Medical' && frequency === 'daily') {
                                        // Edge case: zero base rate
                                        combinations.push({
                                            name: `${category} - ${frequency} - Zero base rate`,
                                            params: {
                                                ...baseCase.params,
                                                baseRate: 0
                                            }
                                        });
                                        
                                        // Edge case: very high base rate
                                        combinations.push({
                                            name: `${category} - ${frequency} - High base rate`,
                                            params: {
                                                ...baseCase.params,
                                                baseRate: 10000
                                            }
                                        });
                                    }
                                    
                                    // Edge case: start age equals end age
                                    if (category === 'Therapy' && frequency === 'weekly' && duration.endAge !== null) {
                                        combinations.push({
                                            name: `${category} - ${frequency} - Start age equals end age`,
                                            params: {
                                                ...baseCase.params,
                                                startAge: duration.startAge,
                                                endAge: duration.startAge
                                            }
                                        });
                                    }
                                    
                                    // Edge case: start age greater than life expectancy
                                    if (category === 'Equipment' && frequency === 'one-time') {
                                        combinations.push({
                                            name: `${category} - ${frequency} - Start age > life expectancy`,
                                            params: {
                                                ...baseCase.params,
                                                startAge: duration.lifeExpectancy + 5
                                            }
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            return combinations;
        }
        
        // Validate calculation result
        function validateCalculationResult(result, params) {
            const validations = [];
            
            // Check if all required properties are present
            const requiredProperties = ['annual', 'lifetime', 'low', 'high', 'average', 'isOneTime'];
            const missingProperties = requiredProperties.filter(prop => result[prop] === undefined);
            
            if (missingProperties.length > 0) {
                validations.push({
                    valid: false,
                    message: `Missing required properties: ${missingProperties.join(', ')}`
                });
            } else {
                validations.push({
                    valid: true,
                    message: 'All required properties are present'
                });
            }
            
            // Check if one-time frequencies are correctly identified
            const parsedFrequency = parseFrequency(params.frequency);
            if (parsedFrequency.valid) {
                if (parsedFrequency.isOneTime === result.isOneTime) {
                    validations.push({
                        valid: true,
                        message: `One-time flag is correctly set to ${result.isOneTime}`
                    });
                } else {
                    validations.push({
                        valid: false,
                        message: `One-time flag should be ${parsedFrequency.isOneTime}, but got ${result.isOneTime}`
                    });
                }
                
                // Check if annual cost is 0 for one-time items
                if (parsedFrequency.isOneTime) {
                    if (result.annual === 0) {
                        validations.push({
                            valid: true,
                            message: 'Annual cost is correctly set to 0 for one-time items'
                        });
                    } else {
                        validations.push({
                            valid: false,
                            message: `Annual cost should be 0 for one-time items, but got ${result.annual}`
                        });
                    }
                }
            }
            
            // Check if lifetime cost is greater than 0 for non-zero base rates
            if (params.baseRate > 0) {
                if (result.lifetime > 0) {
                    validations.push({
                        valid: true,
                        message: 'Lifetime cost is greater than 0 for non-zero base rate'
                    });
                } else {
                    validations.push({
                        valid: false,
                        message: `Lifetime cost should be greater than 0 for non-zero base rate, but got ${result.lifetime}`
                    });
                }
            }
            
            // Check if cost range is valid (low ≤ average ≤ high)
            if (result.low <= result.average && result.average <= result.high) {
                validations.push({
                    valid: true,
                    message: 'Cost range is valid (low ≤ average ≤ high)'
                });
            } else {
                validations.push({
                    valid: false,
                    message: `Cost range is invalid: low=${result.low}, average=${result.average}, high=${result.high}`
                });
            }
            
            return validations;
        }
        
        // Run a single test case
        function runTestCase(testCase) {
            try {
                // Calculate costs
                const result = calculateCosts(testCase.params);
                
                // Validate result
                const validations = validateCalculationResult(result, testCase.params);
                
                // Check if all validations passed
                const passed = validations.every(v => v.valid);
                
                return {
                    testCase,
                    result,
                    validations,
                    passed,
                    error: null
                };
            } catch (error) {
                return {
                    testCase,
                    result: null,
                    validations: [],
                    passed: false,
                    error: error.message
                };
            }
        }
        
        // Run tests
        async function runTests(combinations) {
            const results = [];
            let passedTests = 0;
            let failedTests = 0;
            
            const totalTests = combinations.length;
            
            // Show loading indicator
            document.getElementById('loading').style.display = 'block';
            
            // Process tests in batches to avoid blocking the UI
            const batchSize = 50;
            for (let i = 0; i < combinations.length; i += batchSize) {
                const batch = combinations.slice(i, i + batchSize);
                
                // Process batch
                for (const testCase of batch) {
                    const testResult = runTestCase(testCase);
                    results.push(testResult);
                    
                    if (testResult.passed) {
                        passedTests++;
                    } else {
                        failedTests++;
                    }
                    
                    // Update progress
                    const progress = Math.round(((i + batch.indexOf(testCase) + 1) / totalTests) * 100);
                    document.getElementById('progressBar').style.width = `${progress}%`;
                    document.getElementById('progressBar').textContent = `${progress}%`;
                    document.getElementById('progressText').textContent = `${i + batch.indexOf(testCase) + 1}/${totalTests}`;
                }
                
                // Allow UI to update
                await new Promise(resolve => setTimeout(resolve, 0));
            }
            
            // Hide loading indicator
            document.getElementById('loading').style.display = 'none';
            
            // Show summary
            document.getElementById('summarySection').style.display = 'block';
            document.getElementById('passedCount').textContent = passedTests;
            document.getElementById('failedCount').textContent = failedTests;
            document.getElementById('totalCount').textContent = totalTests;
            
            // Show results
            document.getElementById('resultsSection').style.display = 'block';
            
            return {
                results,
                passedTests,
                failedTests,
                totalTests
            };
        }
        
        // Display test results
        function displayTestResults(results) {
            const container = document.getElementById('resultsContainer');
            container.innerHTML = '';
            
            for (const testResult of results) {
                const testCase = document.createElement('div');
                testCase.className = `test-case ${testResult.passed ? 'passed' : 'failed'}`;
                
                // Create header
                const header = document.createElement('div');
                header.className = 'test-case-header';
                
                const title = document.createElement('h3');
                title.textContent = testResult.testCase.name;
                
                const status = document.createElement('span');
                status.className = testResult.passed ? 'success' : 'error';
                status.textContent = testResult.passed ? 'PASSED' : 'FAILED';
                
                header.appendChild(title);
                header.appendChild(status);
                
                // Create details
                const details = document.createElement('div');
                details.className = 'test-case-details';
                
                // Add parameters
                const paramsTitle = document.createElement('h4');
                paramsTitle.textContent = 'Parameters';
                details.appendChild(paramsTitle);
                
                const paramsJson = document.createElement('pre');
                paramsJson.textContent = JSON.stringify(testResult.testCase.params, null, 2);
                details.appendChild(paramsJson);
                
                // Add result
                if (testResult.result) {
                    const resultTitle = document.createElement('h4');
                    resultTitle.textContent = 'Result';
                    details.appendChild(resultTitle);
                    
                    const resultJson = document.createElement('pre');
                    resultJson.textContent = JSON.stringify(testResult.result, null, 2);
                    details.appendChild(resultJson);
                }
                
                // Add validations
                const validationsTitle = document.createElement('h4');
                validationsTitle.textContent = 'Validations';
                details.appendChild(validationsTitle);
                
                const validationsList = document.createElement('ul');
                for (const validation of testResult.validations) {
                    const validationItem = document.createElement('li');
                    validationItem.className = validation.valid ? 'success' : 'error';
                    validationItem.textContent = validation.message;
                    validationsList.appendChild(validationItem);
                }
                details.appendChild(validationsList);
                
                // Add error
                if (testResult.error) {
                    const errorTitle = document.createElement('h4');
                    errorTitle.textContent = 'Error';
                    details.appendChild(errorTitle);
                    
                    const errorText = document.createElement('p');
                    errorText.className = 'error';
                    errorText.textContent = testResult.error;
                    details.appendChild(errorText);
                }
                
                // Add event listener to toggle details
                header.addEventListener('click', () => {
                    testCase.classList.toggle('expanded');
                });
                
                testCase.appendChild(header);
                testCase.appendChild(details);
                
                container.appendChild(testCase);
            }
        }
        
        // Filter test results
        function filterTestResults(results) {
            const resultFilter = document.getElementById('resultFilter').value;
            const searchFilter = document.getElementById('searchFilter').value.toLowerCase();
            
            let filteredResults = results;
            
            // Filter by result
            if (resultFilter === 'passed') {
                filteredResults = filteredResults.filter(result => result.passed);
            } else if (resultFilter === 'failed') {
                filteredResults = filteredResults.filter(result => !result.passed);
            }
            
            // Filter by search
            if (searchFilter) {
                filteredResults = filteredResults.filter(result => {
                    return result.testCase.name.toLowerCase().includes(searchFilter) ||
                           JSON.stringify(result.testCase.params).toLowerCase().includes(searchFilter);
                });
            }
            
            return filteredResults;
        }
        
        // Populate filter options
        function populateFilterOptions() {
            // Populate category filter
            const categoryFilter = document.getElementById('categoryFilter');
            categoryFilter.innerHTML = '<option value="">Select Category</option>';
            
            for (const category of CARE_CATEGORIES) {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                categoryFilter.appendChild(option);
            }
            
            // Populate frequency filter
            const frequencyFilter = document.getElementById('frequencyFilter');
            frequencyFilter.innerHTML = '<option value="">Select Frequency</option>';
            
            for (const frequency of FREQUENCY_PATTERNS) {
                const option = document.createElement('option');
                option.value = frequency;
                option.textContent = frequency;
                frequencyFilter.appendChild(option);
            }
            
            // Populate duration filter
            const durationFilter = document.getElementById('durationFilter');
            durationFilter.innerHTML = '<option value="">Select Duration</option>';
            
            for (const duration of DURATION_SCENARIOS) {
                const option = document.createElement('option');
                option.value = JSON.stringify(duration);
                option.textContent = duration.description;
                durationFilter.appendChild(option);
            }
            
            // Populate geo filter
            const geoFilter = document.getElementById('geoFilter');
            geoFilter.innerHTML = '<option value="">Select Geographic Adjustment</option>';
            
            for (const geo of GEO_ADJUSTMENT_SCENARIOS) {
                const option = document.createElement('option');
                option.value = geo.zipCode;
                option.textContent = geo.description;
                geoFilter.appendChild(option);
            }
            
            // Populate CPT filter
            const cptFilter = document.getElementById('cptFilter');
            cptFilter.innerHTML = '<option value="">Select CPT Code</option>';
            
            for (const cpt of CPT_CODE_SCENARIOS) {
                const option = document.createElement('option');
                option.value = cpt.cptCode;
                option.textContent = cpt.description;
                cptFilter.appendChild(option);
            }
            
            // Populate age increment filter
            const ageIncrementFilter = document.getElementById('ageIncrementFilter');
            ageIncrementFilter.innerHTML = '<option value="">Select Age Increments</option>';
            
            for (const ageIncrement of AGE_INCREMENT_SCENARIOS) {
                const option = document.createElement('option');
                option.value = JSON.stringify(ageIncrement.value);
                option.textContent = ageIncrement.description;
                ageIncrementFilter.appendChild(option);
            }
        }
        
        // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            // Populate filter options
            populateFilterOptions();
            
            // Run representative tests
            document.getElementById('runRepresentativeTests').addEventListener('click', async () => {
                // Clear previous results
                document.getElementById('resultsContainer').innerHTML = '';
                
                // Generate representative test combinations
                const combinations = generateRepresentativeTestCombinations();
                
                // Run tests
                const { results } = await runTests(combinations);
                
                // Display results
                displayTestResults(results);
                
                // Store results for filtering
                window.testResults = results;
            });
            
            // Run all tests
            document.getElementById('runAllTests').addEventListener('click', async () => {
                // Clear previous results
                document.getElementById('resultsContainer').innerHTML = '';
                
                // Generate all test combinations
                const combinations = generateTestCombinations();
                
                // Run tests
                const { results } = await runTests(combinations);
                
                // Display results
                displayTestResults(results);
                
                // Store results for filtering
                window.testResults = results;
            });
            
            // Run specific test
            document.getElementById('runSpecificTest').addEventListener('click', () => {
                document.getElementById('specificTestConfig').style.display = 'block';
            });
            
            // Run configured test
            document.getElementById('runConfiguredTest').addEventListener('click', async () => {
                // Clear previous results
                document.getElementById('resultsContainer').innerHTML = '';
                
                // Get filter values
                const category = document.getElementById('categoryFilter').value;
                const frequency = document.getElementById('frequencyFilter').value;
                const durationStr = document.getElementById('durationFilter').value;
                const zipCode = document.getElementById('geoFilter').value;
                const cptCode = document.getElementById('cptFilter').value;
                const ageIncrementsStr = document.getElementById('ageIncrementFilter').value;
                
                // Parse values
                const duration = durationStr ? JSON.parse(durationStr) : DURATION_SCENARIOS[0];
                const ageIncrements = ageIncrementsStr ? JSON.parse(ageIncrementsStr) : null;
                
                // Create test case
                const testCase = {
                    name: `${category || 'Any category'} - ${frequency || 'Any frequency'} - ${cptCode ? CPT_CODE_SCENARIOS.find(c => c.cptCode === cptCode)?.description || 'Any CPT code' : 'Any CPT code'}`,
                    params: {
                        category: category || 'Medical',
                        frequency: frequency || 'daily',
                        baseRate: 100,
                        startAge: duration.startAge,
                        endAge: duration.endAge,
                        lifeExpectancy: duration.lifeExpectancy,
                        zipCode: zipCode || '10001',
                        cptCode: cptCode || '99213',
                        ageIncrements
                    }
                };
                
                // Run test
                const { results } = await runTests([testCase]);
                
                // Display results
                displayTestResults(results);
                
                // Store results for filtering
                window.testResults = results;
            });
            
            // Clear results
            document.getElementById('clearResults').addEventListener('click', () => {
                document.getElementById('resultsContainer').innerHTML = '';
                document.getElementById('summarySection').style.display = 'none';
                document.getElementById('resultsSection').style.display = 'none';
                window.testResults = null;
            });
            
            // Filter results
            document.getElementById('resultFilter').addEventListener('change', () => {
                if (window.testResults) {
                    const filteredResults = filterTestResults(window.testResults);
                    displayTestResults(filteredResults);
                }
            });
            
            document.getElementById('searchFilter').addEventListener('input', () => {
                if (window.testResults) {
                    const filteredResults = filterTestResults(window.testResults);
                    displayTestResults(filteredResults);
                }
            });
        });
    </script>
